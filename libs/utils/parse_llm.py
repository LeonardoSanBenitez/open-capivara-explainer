'''
Function to handle text outputs that are usually generated by LLMs
'''
from typing import List, Tuple, Callable, Dict, Optional
import logging
import os
from libs.utils.logger import get_logger
from libs.utils.json_resilient import json_loads_resilient


logger = get_logger(f'libs.utils.{os.path.basename(__file__)}', level = logging.WARNING)


def detect_function_call(response: dict) -> Tuple[bool, Optional[str], Optional[Dict]]:
    '''
    @return is_function_calling: bool
    @return function_name: Optional[str]
    @return function_arguments: Optional[Dict]
    '''
    try:
        if (type(response) == dict) and ("function_call" in response) and (response["function_call"] is not None):
            logger.info('Function calling detected by: native API feature')
            worked, function_arguments = json_loads_resilient(response["function_call"]["arguments"])
            if not worked:
                logger.warning(f"Could not parse, error: {function_arguments}")
                return False, None, None
            else:
                assert type(function_arguments) == dict
                return True, str(response["function_call"]["name"]), function_arguments
        elif (type(response) == dict) and ("content" in response) and (response["content"] is not None):
            logger.info('Function calling detected by: custom implementation')
            worked, content_json = json_loads_resilient(response["content"])
            if not worked:
                logger.warning(f"Could not parse, error: {content_json}")
                return False, None, None
            # Get function name
            # If name isn't found, return False
            assert type(content_json) == dict
            if ('function' in content_json) and (type(content_json['function']) == str):
                function_name = content_json['function']
            elif ('function_call' in content_json) and (type(content_json['function_call']) == str):
                function_name = content_json['function_call']
            elif ('name' in content_json) and (type(content_json['name']) == str):
                function_name = content_json['name']
            else:
                return False, None, None
            if function_name.startswith("functions."):
                function_name = function_name.split("functions.")[1]

            # Get function arguments
            if ('arguments' in content_json) and (type(content_json['arguments']) == dict):
                function_arguments = content_json['arguments']
            elif ('args' in content_json) and (type(content_json['args']) == dict):
                function_arguments = content_json['args']
            elif ('kwargs' in content_json) and (type(content_json['kwargs']) == dict):
                function_arguments = content_json['kwargs']
            else:
                function_arguments = {}
            return True, function_name, function_arguments
        else:
            return False, None, None
    except Exception as e:
        logger.warning(f"Unexpected Error: {e}")
        return False, None, None


map_simplification_to_function: Dict[str, Callable] = {
    'ticks': lambda x: x.replace('`', ''),
    'lowercase': lambda x: x.lower(),
    'underscore': lambda x: x.replace('_', ''),
    'space': lambda x: x.replace(' ', ''),
    'strip': lambda x: x.strip(),
    'hierarchy_leaf_dots': lambda x: x.split('.')[-1],
    'hierarchy_leaf_slashes': lambda x: x.split('/')[-1],
}


def create_apply_all_simplifications(map_simplification_to_function: Dict[str, Callable]) -> Callable:
    new_mapping = map_simplification_to_function.copy()

    def apply_all_simplifications(x: str) -> str:
        for simplification_name, simplification_func in new_mapping.items():
            x = simplification_func(x)
        return x
    return apply_all_simplifications


def match_key_from_candidates(key: str, candidates: List[str], required: bool = True, exception_message: str = 'key not found', custom_simplifications: Dict[str, Callable] = {}) -> Optional[str]:
    '''
    Best effort matching.
    Return a value from candidates that matches the key, in its original form (before any transformation)
    Considered a match if:
    1. The key is exactly in the candidates; or
    2. There is a unique match possibility after applying a series of transformations/simplifications/normalizations.
       That is, exactly one candidate (and more no than one) can be transformed into the transformed key.

    If there is no match, raises an exception (when required is True) or returns None (when required is False).

    @param custom_exception_message: only used when required is True
    @custom_simplifications: more transformations to apply. These will be included in the 'all_simplifications' transformation.
    '''
    # TODO: receive list of simplifications as a parameter?
    assert type(key) == str
    assert type(candidates) == list
    assert len(candidates) > 0
    assert all([type(candidate) == str for candidate in candidates])
    assert len(candidates) == len(set(candidates)), 'Candidates are not unique'

    map_simplification_to_function_expanded = map_simplification_to_function.copy()
    for simplification_name, simplification_func in custom_simplifications.items():
        assert simplification_name not in map_simplification_to_function_expanded, f'Repeated simplification name: {simplification_name}'
        map_simplification_to_function_expanded[simplification_name] = simplification_func
    assert 'all_simplifications' not in map_simplification_to_function, 'Reserved simplification name: all_simplifications'
    map_simplification_to_function_expanded['all_simplifications'] = create_apply_all_simplifications(map_simplification_to_function_expanded)
    assert len(map_simplification_to_function_expanded) == len(map_simplification_to_function) + 1 + len(custom_simplifications)

    best_candidate = None

    # Exact match
    if key in candidates:
        best_candidate = key

    # Transforming just the key
    if best_candidate is None:
        for simplification_name, simplification_func in map_simplification_to_function_expanded.items():
            transformed_key = simplification_func(key)
            transformed_candidates = [simplification_func(candidate) for candidate in candidates]
            if transformed_key in candidates:
                if transformed_candidates.count(transformed_key) != 1:
                    logger.info(f"Transformation {simplification_name} leads to non-unique candidates, skipping")
                    continue
                logger.info(f"Candidate found by {simplification_name} transformation (key-only)")
                best_candidate = transformed_key
                break

    # Transforming all candidates
    if best_candidate is None:
        for simplification_name, simplification_func in map_simplification_to_function_expanded.items():
            transformed_key = simplification_func(key)
            transformed_candidates = [simplification_func(candidate) for candidate in candidates]
            if transformed_key in transformed_candidates:
                if transformed_candidates.count(transformed_key) != 1:
                    logger.info(f"Transformation {simplification_name} leads to non-unique candidates, skipping")
                    continue
                logger.info(f"Candidate found by {simplification_name} transformation (candidates and key)")
                best_candidate = candidates[transformed_candidates.index(transformed_key)]
                break

    # Post validation
    if required:
        if best_candidate is None:
            raise ValueError(exception_message)
        assert best_candidate in candidates
        return best_candidate
    else:
        assert (best_candidate in candidates) or (best_candidate is None)
        return best_candidate
